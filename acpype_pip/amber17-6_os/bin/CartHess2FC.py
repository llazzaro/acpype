#!/opt/anaconda1anaconda2anaconda3/bin/python
# Filename: CartHess2FC.py
"""
This is the CartHess2FC.py program written by Pengfei Li in Merz Research Group
at Michigan State University.
It is designed to get the force constant from Hessian Matrix based on Seminario
or Z-matrix method.

The Seminario method is from:
** J. M. Seminario IJQC, 1996, 30, 1271-1277
"""
#------------------------------------------------------------------------------
# Load modules
#------------------------------------------------------------------------------
from __future__ import absolute_import, print_function
from pymsmt.mcpb.gene_final_frcmod_file import (get_bond_fc_with_sem,
     get_ang_fc_with_sem, get_dih_fc_with_sem, get_imp_fc_with_sem,
     get_fc_from_log)
from pymsmt.mol.constants import *
from pymsmt.mol.readpdb import get_atominfo_fpdb
from pymsmt.mol.getlist import get_blist, get_all_list
from pymsmt.mol.gauio import get_crds_from_fchk, get_matrix_from_fchk
from pymsmt.mol.gmsio import get_crds_from_gms, get_matrix_from_gms
from pymsmt.exp import pymsmtError
from pymsmt.title import print_title
from optparse import OptionParser

#------------------------------------------------------------------------------
# Define some functions
#------------------------------------------------------------------------------
def print_method_title(method):
    if method == 'Z':
        print("The Following Force Field Parameters Are Generated by "
              "Z-matrix Method")
        print("="*32 + "Units" + "="*32)

    elif method == 'S':
        print("The Following Force Field Parameters Are Generated by "
              "Seminario Method")
        print("="*33 + "Units" + "="*32)

    align = 35

    print("Bond Force Constant :".rjust(align) + \
          " kcal/(mol*Angstrom^2)")
    print("Equilibrium Bond Distance :".rjust(align) + " Angstrom")

    print("1-3 Force Constant :".rjust(align) + \
          " kcal/(mol*Angstrom^2)")
    print("Equilibrium 1-3 Distance :".rjust(align) + " Angstrom")

    print("Angle Force Constant :".rjust(align) + \
          " kcal/(mol*Radian^2)")
    print("Equilibrium Angle Value :".rjust(align) + " Degree")

    print("Dihedral Harmonic Force Constant :".rjust(align) + \
          " kcal/(mol*Radian^2)")
    print("Equilibrium Dihedral Value :".rjust(align) + " Degree")

    if method == 'S':
        print("Improper Harmonic Force Constant :".rjust(align) + \
                      " kcal/(mol*Angstrom^2)")
        print("Equilibrium Distance to Plane 124 :".rjust(align) + " Angstrom")

def atom_rep(mol, atn):
    atn_rep = mol.atoms[atn].resname + str(mol.atoms[atn].resid) + '@' \
              + mol.atoms[atn].atname
    atn_rep = atn_rep.center(11)
    return atn_rep

# Bond
def print_bond_title():
    print(27 * '=' + "Bond Parameters" + 27 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11),
          'Bond Force Constant'.center(19),
          'Equilibrium Bond Distance'.center(25), sep='|')

def print_bond_inf(at1_rep, at2_rep, fcfinal, dis):
    print(at1_rep, at2_rep, str(round(fcfinal, 1)).center(19),
          str(round(dis, 4)).center(25), sep='|')

def print_bond_title_wsd():
    print(32 * '=' + "Bond Parameters" + 31 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11),
          'Bond Force Constant (StdDev)'.center(28),
          'Equilibrium Bond Distance'.center(25), sep='|')

def print_bond_inf_wsd(at1_rep, at2_rep, fcfinal, stdv, dis):
    wsd = str(round(fcfinal, 1)) + "(" + str(round(stdv, 1)) + ")"
    print(at1_rep, at2_rep, wsd.center(28),
          str(round(dis, 4)).center(25), sep='|')

# Urey-Bradley (1-3 interaction)
def print_13_title():
    print(23 * '=' + "Urey-Bradley Parameters" + 23 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11),
          '1-3 Force Constant'.center(18),
          'Equilibrium 1-3 Distance'.center(24), sep='|')

def print_13_inf(at1_rep, at2_rep, fcfinal, dis):
    print(at1_rep, at2_rep, str(round(fcfinal, 1)).center(18),
          str(round(dis, 4)).center(24), sep='|')

def print_13_title_wsd():
    print(28 * '=' + "Urey-Bradley Parameters" + 27 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11),
          '1-3 Force Constant (StdDev)'.center(27),
          'Equilibrium 1-3 Distance'.center(24), sep='|')

def print_13_inf_wsd(at1_rep, at2_rep, fcfinal, stdv, dis):
    wsd = str(round(fcfinal, 1)) + "(" + str(round(stdv, 1)) + ")"
    print(at1_rep, at2_rep, wsd.center(27),
          str(round(dis, 4)).center(24), sep='|')

# Angle
def print_angle_title():
    print(32 * '=' + "Angle Parameters" + 32 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11), 'Atom 3'.center(11),
          'Angle Force Constant'.center(20),
          'Equilibrium Angle Value'.center(23), sep='|')

def print_angle_inf(at1_rep, at2_rep, at3_rep, fcfinal, angval):
    print(at1_rep, at2_rep, at3_rep, str(round(fcfinal, 2)).center(20),
          str(round(angval, 2)).center(23), sep='|')

def print_angle_title_wsd():
    print(37 * '=' + "Angle Parameters" + 36 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11), 'Atom 3'.center(11),
          'Angle Force Constant (StdDev)'.center(29),
          'Equilibrium Angle Value'.center(23), sep='|')

def print_angle_inf_wsd(at1_rep, at2_rep, at3_rep, fcfinal, stdv, angval):
    wsd = str(round(fcfinal, 2)) + "(" + str(round(stdv, 2)) + ")"
    print(at1_rep, at2_rep, at3_rep, wsd.center(29),
          str(round(angval, 2)).center(23), sep='|')

# Dihedral
def print_dih_title():
    print(44 * '=' + "Dihedral Parameters" + 44 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11), 'Atom 3'.center(11),
        'Atom 4'.center(11), 'Dihedral Harmonic Force Constant'.center(32),
        'Equilibrium Dihedral Value'.center(26), sep='|')

def print_dih_inf(at1_rep, at2_rep, at3_rep, at4_rep, fcfinal, dihval):
    print(at1_rep, at2_rep, at3_rep, at4_rep,
        str(round(fcfinal, 2)).center(32),
        str(round(dihval, 2)).center(26), sep='|')

# Improper
def print_imp_title():
    print(48 * '=' + "Improper Parameters" + 48 * '=')
    print('Atom 1'.center(11), 'Atom 2'.center(11), 'Atom 3(Cen)'.center(11),
        'Atom 4'.center(11), 'Improper Harmonic Force Constant'.center(32),
        'Equilibrium Distance to Plane 124'.center(33), sep='|')

def print_imp_inf(at1_rep, at2_rep, at3_rep, at4_rep, fcfinal, dis):
    print(at1_rep, at2_rep, at3_rep, at4_rep,
        str(round(fcfinal, 2)).center(32), str(round(dis, 4)).center(33),
        sep='|')

def get_all_fc_with_zmatrix(mol, atids, logfname, scalef):
    """Generate all the force constants with Z-matrix method"""

    print_method_title('Z')

    # Reverse new id dict
    rvnatids = {}
    for i in xrange(len(atids)):
        rvnatids[i+1] = atids[i]

    # Get information from the log file
    sturefs, vals, fcs = get_fc_from_log(logfname)

    # Print the Bond part
    print_bond_title()
    for i in xrange(len(sturefs)):
        if len(sturefs[i]) == 2:
            at1 = rvnatids[sturefs[i][0]]
            at2 = rvnatids[sturefs[i][1]]
            dis = vals[i]
            fcfinal = fcs[i] * HB2_TO_KCAL_MOL_A2 * 0.5
            fcfinal = fcfinal * scalef * scalef

            at1_rep = atom_rep(mol, at1)
            at2_rep = atom_rep(mol, at2)
            print_bond_inf(at1_rep, at2_rep, fcfinal, dis)

    # Print the Angle part
    print_angle_title()
    for i in xrange(len(sturefs)):
        if len(sturefs[i]) == 3:
            at1 = rvnatids[sturefs[i][0]]
            at2 = rvnatids[sturefs[i][1]]
            at3 = rvnatids[sturefs[i][2]]
            angval = vals[i]
            fcfinal = fcs[i] * H_TO_KCAL_MOL * 0.5

            at1_rep = atom_rep(mol, at1)
            at2_rep = atom_rep(mol, at2)
            at3_rep = atom_rep(mol, at3)
            print_angle_inf(at1_rep, at2_rep, at3_rep, fcfinal, angval)

    # Print the dihedral part
    print_dih_title()
    for i in xrange(len(sturefs)):
        if len(sturefs[i]) == 4:
            at1 = rvnatids[sturefs[i][0]]
            at2 = rvnatids[sturefs[i][1]]
            at3 = rvnatids[sturefs[i][2]]
            at4 = rvnatids[sturefs[i][3]]
            dihval = vals[i]
            fcfinal = fcs[i] * H_TO_KCAL_MOL * 0.5

            at1_rep = atom_rep(mol, at1)
            at2_rep = atom_rep(mol, at2)
            at3_rep = atom_rep(mol, at3)
            at4_rep = atom_rep(mol, at4)
            print_dih_inf(at1_rep, at2_rep, at3_rep, at4_rep, fcfinal, dihval)

def get_all_fc_with_sem(mol, atids, hessf, prog, scalef, bondavg, avg13, angavg):
    """Generate all the force constants with Z-matrix method"""

    print_method_title('S')

    # Get the new atom ids
    natids = {}
    for i in xrange(0, len(atids)):
        natids[atids[i]] = i + 1

    # Get the connection list
    blist = get_blist(mol, atids)
    all_list = get_all_list(mol, blist, atids, 8.0)

    # Crds after optimization
    if prog in ['g03', 'g09']:
        crds = get_crds_from_fchk(hessf, len(atids))
    elif prog == 'gms':
        crds = get_crds_from_gms(hessf)

    # Whole Hessian Matrix
    if prog in ['g03', 'g09']:
        fcmatrix = get_matrix_from_fchk(hessf, 3*len(atids))
    elif prog == 'gms':
        fcmatrix = get_matrix_from_gms(hessf, 3*len(atids))

    # Print the bond part
    if bondavg is True:
        print_bond_title_wsd()
    else:
        print_bond_title()

    for i in all_list.bondlist:
        at1 = i[0]
        at2 = i[1]
        nat1 = natids[at1]
        nat2 = natids[at2]
        at1_rep = atom_rep(mol, at1)
        at2_rep = atom_rep(mol, at2)

        crds0 = []
        if bondavg is True:
            dis, fcfinal, stdv = get_bond_fc_with_sem(crds0, crds, fcmatrix, nat1,
                nat2, scalef, 1)
            print_bond_inf_wsd(at1_rep, at2_rep, fcfinal, stdv, dis)
        else:
            dis, fcfinal = get_bond_fc_with_sem(crds0, crds, fcmatrix, nat1, nat2,
                scalef, 0)
            print_bond_inf(at1_rep, at2_rep, fcfinal, dis)

    # Print the 1-3 part
    if avg13 is True:
        print_13_title_wsd()
    else:
        print_13_title()

    for i in all_list.anglist:
        at1 = i[0]
        at3 = i[2]
        nat1 = natids[at1]
        nat3 = natids[at3]
        at1_rep = atom_rep(mol, at1)
        at3_rep = atom_rep(mol, at3)

        crds0 = []
        if avg13 is True:
            dis, fcfinal, stdv = get_bond_fc_with_sem(crds0, crds, fcmatrix, nat1,
                nat3, scalef, 1)
            print_13_inf_wsd(at1_rep, at3_rep, fcfinal, stdv, dis)
        else:
            dis, fcfinal = get_bond_fc_with_sem(crds0, crds, fcmatrix, nat1, nat3,
                scalef, 0)
            print_13_inf(at1_rep, at3_rep, fcfinal, dis)

    # Print the Angle part
    if angavg is True:
        print_angle_title_wsd()
    else:
        print_angle_title()

    for i in all_list.anglist:
        at1 = i[0]
        at2 = i[1]
        at3 = i[2]
        nat1 = natids[at1]
        nat2 = natids[at2]
        nat3 = natids[at3]
        at1_rep = atom_rep(mol, at1)
        at2_rep = atom_rep(mol, at2)
        at3_rep = atom_rep(mol, at3)

        crds0 = []
        if angavg is True:
            angval, fcfinal, stdv = get_ang_fc_with_sem(crds0, crds, fcmatrix, nat1,
                nat2, nat3, scalef, 1)
            print_angle_inf_wsd(at1_rep, at2_rep, at3_rep,
                fcfinal, stdv, angval)
        else:
            angval, fcfinal = get_ang_fc_with_sem(crds0, crds, fcmatrix, nat1, nat2,
                nat3, scalef, 0)
            print_angle_inf(at1_rep, at2_rep, at3_rep, fcfinal, angval)

    # Print the Dihedral part
    print_dih_title()
    for i in all_list.dihlist:
        at1 = i[0]
        at2 = i[1]
        at3 = i[2]
        at4 = i[3]
        nat1 = natids[at1]
        nat2 = natids[at2]
        nat3 = natids[at3]
        nat4 = natids[at4]
        at1_rep = atom_rep(mol, at1)
        at2_rep = atom_rep(mol, at2)
        at3_rep = atom_rep(mol, at3)
        at4_rep = atom_rep(mol, at4)
        dihval, fcfinal = get_dih_fc_with_sem(crds, fcmatrix, nat1, nat2, nat3,
            nat4, scalef)
        print_dih_inf(at1_rep, at2_rep, at3_rep, at4_rep, fcfinal, dihval)

    # Print the Improper part
    print_imp_title()
    for i in all_list.implist:
        at1 = i[0]
        at2 = i[1]
        at3 = i[2] #Central atom
        at4 = i[3]
        nat1 = natids[at1]
        nat2 = natids[at2]
        nat3 = natids[at3]
        nat4 = natids[at4]
        at1_rep = atom_rep(mol, at1)
        at2_rep = atom_rep(mol, at2)
        at3_rep = atom_rep(mol, at3)
        at4_rep = atom_rep(mol, at4)

        if mol.atoms[at1].element == mol.atoms[at2].element:
            fcfinal, dis = get_imp_fc_with_sem(crds, fcmatrix, nat3,
                nat1, nat2, nat4, scalef) #Treat the central atom first
            print_imp_inf(at1_rep, at2_rep, at3_rep, at4_rep, fcfinal, dis)
        elif mol.atoms[at1].element == mol.atoms[at4].element:
            fcfinal, dis = get_imp_fc_with_sem(crds, fcmatrix, nat3,
                nat1, nat4, nat2, scalef) #Treat the central atom first
            print_imp_inf(at1_rep, at4_rep, at3_rep, at2_rep, fcfinal, dis)
        elif mol.atoms[at2].element == mol.atoms[at4].element:
            fcfinal, dis = get_imp_fc_with_sem(crds, fcmatrix, nat3,
                nat2, nat4, nat1, scalef) #Treat the central atom first
            print_imp_inf(at4_rep, at2_rep, at3_rep, at1_rep, fcfinal, dis)
        else:
            fcfinal, dis = get_imp_fc_with_sem(crds, fcmatrix, nat3,
                nat1, nat2, nat4, scalef) #Treat the central atom first
            print_imp_inf(at1_rep, at2_rep, at3_rep, at4_rep, fcfinal, dis)

#------------------------------------------------------------------------------
# Main Program
#------------------------------------------------------------------------------
parser = OptionParser("Usage: CartHess2FC.py -p PDB_file -f Hess_file "
                      "[-v software] [-m method]\n"
                      "                      [--scalef freq_scale_factor] "
                      "[--nstpdb]\n"
                      "                      [--bavg] [--avg13] [--aavg]")

parser.set_defaults(softv='g03', method='sem', scalef=1.000)
parser.add_option("-p", dest="pdbf", type='string',
                  help="Input PDB file name")
parser.add_option("-f", dest="hessf", type='string',
                  help="Quantum output file name (a fchk/log file for "
                       "Gaussian or a log file for GAMESS-US).")
parser.add_option("-v", dest="softv", type='string',
                  help="Software version [Default is g03 (means Gaussian03), "
                       "other options are, g09 (means Gaussian09), and gms "
                       "(means GAMESS-US)]")
parser.add_option("-m", dest="method", type='string',
                  help="Method used. [Default is sem (means Seminario, "
                       "appliable for g03, g09, and gms) other option is zmx "
                       "(means Z-matrix, only appliable for g03 and g09.)]")
parser.add_option("--scalef", dest="scalef", type='float',
                  help="Scale factor (ATTENTION: This is the scale factor of "
                       "frequency. The force constants will be scaled by "
                       "multiplying the square of scale_factor).")
parser.add_option("--nstpdb", dest="nstpdb", action="store_true", default=False,
                  help="Non standard PDB file used. It is the PDB file which "
                       "have all the atom names as element followed by interger "
                       "number. It could be a PDB file generated by software "
                       "such as antechamber based on the Gaussian output file.")
parser.add_option("--bavg", dest="bavg", action="store_true", default=False,
                  help="Make averge of bond force constants based on "
                       "different ways of chosing sub Hessian matrices using "
                       "Seminario method.")
parser.add_option("--avg13", dest="avg13", action="store_true", default=False,
                  help="Make averge of Urey-Bradley force constants based on "
                        "different ways of chosing sub Hessian matrices using "
                        "Seminario method.")
parser.add_option("--aavg", dest="aavg", action="store_true", default=False,
                  help="Make averge of bond force constants based on "
                       "different ways of chosing sub Hessian matrices using "
                       "Seminario method.")
(options, args) = parser.parse_args()

# Print the title of the program
version = '2.0'
print_title('CartHess2FC.py', version)

# Not suport combinations
if options.softv == 'gms' and options.method == 'Z':
    raise pymsmtErorr("Don\'t support Z-matrix method using GAMESS-US in "
                      "current verison!")

avg = options.bavg or options.avg13 or options.aavg

if avg is True and options.method == 'Z':
    raise pymsmtError("Make average of force constants are not applicable "
                      "to Z-matrix method.")

# Get the molecular information from the PDB file
mol, atids, resids = get_atominfo_fpdb(options.pdbf)

if options.nstpdb is True:
    for i in atids:
        atname = mol.atoms[i].atname
        if atname[1] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']:
            mol.atoms[i].element = atname[0]
        else:
            mol.atoms[i].element = atname[0:2]

# Print the results with different method
if options.method.lower() == 'zmx':
    get_all_fc_with_zmatrix(mol, atids, options.hessf, options.scalef)
elif options.method.lower() == 'sem':
    get_all_fc_with_sem(mol, atids, options.hessf, options.softv,
        options.scalef, options.bavg, options.avg13, options.aavg)

quit()
